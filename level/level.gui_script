local M = require("scripts.manager")
local C = require("scripts.config")

local function theme_play()
    --sound.play("/sound_controller#theme")
end

local function theme_stop()
    sound.stop("/sound_controller#theme")
end

local function sound_toggle()
	local texture = M.sound_on and "sound_off" or "sound_on"
	gui.play_flipbook(gui.get_node("sound_pie"), texture)

	M.sound_on = not M.sound_on

	if M.sound_on then
		theme_play()
	else
		theme_stop()
	end
end

local function show_win_message(self, show)
	if (show) then
		local x = C.SCREEN_WIDTH / 2
		local y = C.SCREEN_HEIGHT / 2
		gui.set_position(self.button_next, vmath.vector3(x, y, 0))
		gui.set_position(self.win_message, vmath.vector3(x, y + 100, 0))
	else
		gui.set_position(self.button_next, vmath.vector3(-1000, -1000, 0))
		gui.set_position(self.win_message, vmath.vector3(-1000, -1000, 0))
	end
end

local function animate_level_label(self)
	gui.set_text(self.level_label, tostring(M.current_world .. "-" .. M.current_level))

	local hold_duration = 3
	local animation_duration = 0.5
	local final_scale_percent = 2
	local top_margin = 50 -- en píxeles
	-- LÓGICA DE LA ANIMACIÓN
	-- Calcular la posición y escala finales ---
	local target_x = (C.SCREEN_WIDTH / 2) - (gui.get_size(self.level_label).x / 8)
	local target_y = C.SCREEN_HEIGHT + top_margin
	-- Creamos los vectores para la animación
	local target_position = vmath.vector3(target_x, target_y, 0)
	local target_scale = vmath.vector3(final_scale_percent, final_scale_percent, 1)
	-- Programar las animaciones ---
	-- 1. Animación de la POSICIÓN
	gui.animate(
		self.level_label,
		"position",
		target_position,
		gui.EASING_OUTCIRC,
		animation_duration,
		hold_duration, -- IMPORTANTE: El retraso antes de que empiece la animación
		nil          -- callback function opcional
	)
	-- 2. Animación de la ESCALA (se ejecutará al mismo tiempo que la de posición)
	gui.animate(
		self.level_label,
		"scale",
		target_scale,
		gui.EASING_OUTCIRC,
		animation_duration,
		hold_duration, -- Usamos el mismo retraso para que se sincronicen
		nil
	)
end

function init(self)
	msg.post(".", "acquire_input_focus")
	self.sound_button = gui.get_node("sound_button")
	self.button_next = gui.get_node("button_next")
	self.button_x = gui.get_node("button_x")
	self.win_message = gui.get_node("win_message")
	self.level_label = gui.get_node("level_label")
	--show_ui(self)
	animate_level_label(self)
	show_win_message(self, false)
	local texture = M.sound_on and "sound_on" or "sound_off"
	gui.play_flipbook(gui.get_node("sound_pie"), texture)

	if (M.sound_on) then
			msg.post("main:/main", "theme_stop")
			theme_play()
	end
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.pressed then
		if gui.pick_node(self.button_next, action.x, action.y) then
			msg.post("main:/main", "change_scene", { scene = M.SCENES.LEVELS })
		end

		if gui.pick_node(self.button_x, action.x, action.y) then
			msg.post("main:/main", "change_scene", { scene = M.SCENES.LEVELS })
		end

		if gui.pick_node(self.sound_button, action.x, action.y) then
			sound_toggle()
		end
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("show_win_message") then
		show_win_message(self, true)
	end
end
