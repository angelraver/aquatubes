local M = require("scripts.manager")
local C = require "scripts.config"
local WORLD_COUNT = 6
local LEVEL_COUNT = 20

local function generate_world_grid(self)
	local button_template = gui.get_node("world_button_template")
	local columns = 3
	local button_size = gui.get_size(button_template)
	local spacing = vmath.vector3(20, 20, 0) -- Espacio entre botones
	local start_x = 200
	local start_y = C.SCREEN_HEIGHT - 100

	for i = 1, WORLD_COUNT do
		local row = math.floor((i - 1) / columns)
		local col = (i - 1) % columns
		local pos_x = start_x + col * (button_size.x + spacing.x)
		local pos_y = start_y - row * (button_size.y + spacing.y)
		local position = vmath.vector3(pos_x, pos_y, 0)
		local new_button_nodes = gui.clone_tree(button_template)-- Clona el árbol de nodos de la plantilla (el botón y su texto hijo)
		local button_node = new_button_nodes[gui.get_id(button_template)]-- El nodo principal del botón
		gui.set_position(button_node, position)
		gui.set_enabled(button_node, true)
		local text_node_template = gui.get_node("world_number")-- El nodo de texto hijo
		local text_node = new_button_nodes[gui.get_id(text_node_template)]
		gui.set_text(text_node, tostring("World " .. i))
		local is_open = true
		local sprite_name
		if i < M.current_world then
			sprite_name = "world_done"
		elseif i == M.current_world then
			sprite_name = "world"
		else
			is_open = false
			sprite_name = "world_blocked"
		end

		table.insert(self.world_buttons, {
			node = button_node,
			world = i,
			open = is_open
		})

		gui.play_flipbook(button_node, hash(sprite_name))
	end

	gui.set_enabled(button_template, false)-- Deshabilita la plantilla original para que no sea visible
end

local function generate_level_grid(self)
	local button_template = gui.get_node("level_button_template")
	local columns = 4
	local button_size = gui.get_size(button_template)
	local spacing = vmath.vector3(20, 20, 0) -- Espacio entre botones
	local start_x = 200
	local start_y = 400

	for i = 1, LEVEL_COUNT do
		local row = math.floor((i - 1) / columns)
		local col = (i - 1) % columns
		local pos_x = start_x + col * (button_size.x + spacing.x)
		local pos_y = start_y - row * (button_size.y + spacing.y)
		local position = vmath.vector3(pos_x, pos_y, 0)
		local new_button_nodes = gui.clone_tree(button_template)-- Clona el árbol de nodos de la plantilla (el botón y su texto hijo)
		local button_node = new_button_nodes[gui.get_id(button_template)]-- El nodo principal del botón
		gui.set_position(button_node, position)
		gui.set_enabled(button_node, true)
		local text_node_template = gui.get_node("level_number")-- El nodo de texto hijo
		local text_node = new_button_nodes[gui.get_id(text_node_template)]
		gui.set_text(text_node, tostring(i))
		local is_open = true
		local sprite_name
		if i < M.current_level then
			sprite_name = "level_done"
		elseif i == M.current_level then
			sprite_name = "level"
		else
			is_open = false
			sprite_name = "level_blocked"
		end

		gui.play_flipbook(button_node, hash(sprite_name))

		table.insert(self.level_buttons, {
			node = button_node,
			level = i,
			open = is_open
		})
	end

	gui.set_enabled(button_template, false)-- Deshabilita la plantilla original para que no sea visible
end

function init(self)
	msg.post(".", "acquire_input_focus")
	self.level_buttons = {}
	self.world_buttons = {}
	M.refresh_levels()
	generate_world_grid(self)
	generate_level_grid(self)
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.pressed then

		for i, world_button in ipairs(self.world_buttons) do
			if gui.pick_node(world_button.node, action.x, action.y) then
				if world_button.open then
					M.current_world = world_button.world
					generate_level_grid(self)
					sound.play("main:/main#enter")
				else
					sound.play("main:/main#blocked")
				end
				return true
			end
		end

		for i, level_button in ipairs(self.level_buttons) do
			if gui.pick_node(level_button.node, action.x, action.y) then
				if level_button.open then
					M.current_level = level_button.level
					msg.post("main:/main", "change_scene", { scene = M.SCENES.LEVEL })
					sound.play("main:/main#enter")
				else
					sound.play("main:/main#blocked")
				end
				return true
			end
		end
	end
	return false
end