local M = require("scripts.manager")
local C = require "scripts.config"

local function generate_world_grid(self)
    local button_template = gui.get_node("world_button_template")
 	local columns = 3
 	local button_size = gui.get_size(button_template)
 	local spacing = vmath.vector3(20, 20, 0)
 	local start_x = 180
 	local start_y = C.SCREEN_HEIGHT - 80

 	for i = 1, C.WORLD_COUNT do
 		local row = math.floor((i - 1) / columns)
 		local col = (i - 1) % columns
 		local pos_x = start_x + col * (button_size.x + spacing.x)
 		local pos_y = start_y - row * (button_size.y + spacing.y)
 		local position = vmath.vector3(pos_x, pos_y, 0)
 		local new_button_nodes = gui.clone_tree(button_template)
 		local button_node = new_button_nodes[gui.get_id(button_template)]
 		gui.set_position(button_node, position)
 		gui.set_enabled(button_node, true)
 		local text_node_template = gui.get_node("world_number")
 		local text_node = new_button_nodes[gui.get_id(text_node_template)]
 		gui.set_text(text_node, tostring("World \n" .. i))
 		table.insert(self.world_buttons, {
 			node = button_node,
 			world = i,
 			open = false,
 			done = false
 		})

 	end

    gui.set_enabled(button_template, false)
end

local function refresh_world_grid(self)
    for i, world_button in ipairs(self.world_buttons) do
        local sprite_name = "world_blocked" -- Por defecto, bloqueado
        world_button.open = false
        world_button.done = false

        -- ¿El mundo está desbloqueado? (es decir, existe en nuestra tabla de progreso)
        if M.progress.worlds[world_button.world] ~= nil then
            sprite_name = "world"
            world_button.open = true
        end

        -- ¿El mundo está completado? (tiene C.LEVEL_COUNT niveles hechos)
        if M.progress.worlds[world_button.world] == C.LEVEL_COUNT then
            sprite_name = "world_done"
            world_button.done = true
        end

        -- ¿Es el mundo actualmente seleccionado?
        if world_button.world == M.current_world then
            sprite_name = "world_selected"
        end

        gui.play_flipbook(world_button.node, hash(sprite_name))
    end
end

local function generate_level_grid(self)
    local button_template = gui.get_node("level_button_template")
 	local columns = 4
 	local button_size = gui.get_size(button_template)
 	local spacing = vmath.vector3(20, 20, 0) -- Espacio entre botones
 	local start_x = 157
 	local start_y = 560

 	for i = 1, C.LEVEL_COUNT do
 		local row = math.floor((i - 1) / columns)
 		local col = (i - 1) % columns
 		local pos_x = start_x + col * (button_size.x + spacing.x)
 		local pos_y = start_y - row * (button_size.y + spacing.y)
 		local position = vmath.vector3(pos_x, pos_y, 0)
 		local new_button_nodes = gui.clone_tree(button_template)
 		local button_node = new_button_nodes[gui.get_id(button_template)]
 		gui.set_position(button_node, position)
 		gui.set_enabled(button_node, true)
 		local text_node_template = gui.get_node("level_number")
 		local text_node = new_button_nodes[gui.get_id(text_node_template)]
 		gui.set_text(text_node, tostring(i))
 		local is_open = false
 		local is_done = false
 		table.insert(self.level_buttons, {
 			node = button_node,
 			level = i,
 			open = is_open,
 			done = is_done
 		})
 	end

    gui.set_enabled(button_template, false)-- Deshabilita la plantilla original para que no sea visible
end

local function refresh_level_grid(self)
    -- Obtenemos el progreso del mundo actual. Si el mundo está bloqueado, será `nil`.
    local completed_in_world = M.progress.worlds[M.current_world]

    -- Si el mundo está bloqueado, no hacemos nada (todos los niveles quedarán bloqueados).
    if completed_in_world == nil then
        completed_in_world = -1 -- Un valor que asegura que todos los niveles estén bloqueados.
    end

    for i, level_button in ipairs(self.level_buttons) do
        local sprite_name
        level_button.open = false
        level_button.done = false

        -- 1. Nivel completado (done)
        if level_button.level <= completed_in_world then
            sprite_name = "level_done"
            level_button.open = true
            level_button.done = true
        -- 2. Siguiente nivel a jugar (open)
        elseif level_button.level == completed_in_world + 1 then
            sprite_name = "level"
            level_button.open = true
        -- 3. Nivel bloqueado
        else
            sprite_name = "level_blocked"
        end

        gui.play_flipbook(level_button.node, hash(sprite_name))
    end

end

function init(self)
    msg.post(".", "acquire_input_focus")
    self.level_buttons = {}
    self.world_buttons = {}

    generate_world_grid(self)
    generate_level_grid(self)

    refresh_world_grid(self)
    refresh_level_grid(self)
end

function on_input(self, action_id, action)
    if action_id == hash("touch") and action.pressed then

        for i, world_button in ipairs(self.world_buttons) do
            if gui.pick_node(world_button.node, action.x, action.y) then
                if world_button.open then
                    M.current_world = world_button.world
                    -- Refrescamos ambas grillas al cambiar de mundo
                    refresh_world_grid(self)
                    refresh_level_grid(self)
                    --sound.play("main:/main#enter")
                else
                    --sound.play("main:/main#blocked")
                end
                return true
            end
        end

        for i, level_button in ipairs(self.level_buttons) do
            if gui.pick_node(level_button.node, action.x, action.y) then
                if level_button.open then
                    M.current_level = level_button.level
                    msg.post("main:/main", "change_scene", { scene = M.SCENES.LEVEL })
                    --sound.play("main:/main#enter")
                else
                    --sound.play("main:/main#blocked")
                end
                return true
            end
        end
    end
    return false
end