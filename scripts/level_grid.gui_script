local MANAGER = require("scripts.manager")

function init(self)
	-- Tabla que almacena la información de los niveles.
	-- Puedes cargar esto desde un archivo de guardado en un juego real.
	self.levels_data = {
		{ level = 1, open = true, done = false },
		{ level = 2, open = true, done = true },
		{ level = 3, open = true, done = false },
		{ level = 4, open = false, done = false },
		{ level = 5, open = false, done = false },
		{ level = 6, open = false, done = false },
		{ level = 7, open = false, done = false },
		{ level = 8, open = false, done = false },
		{ level = 9, open = false, done = false },
		{ level = 10, open = false, done = false },
		{ level = 11, open = false, done = false },
		{ level = 12, open = false, done = false },
		{ level = 13, open = false, done = false },
		{ level = 14, open = false, done = false },
		{ level = 15, open = false, done = false }
	}

	-- Almacenaremos los nodos de los botones clonados aquí
	self.level_buttons = {}

	-- Llama a la función para generar la grilla de niveles
	generate_level_grid(self)

	-- Le dice al motor que este script quiere recibir eventos de input
	msg.post(".", "acquire_input_focus")
end

function generate_level_grid(self)
	-- Obtiene la plantilla del botón que creamos en el editor de GUI
	local button_template = gui.get_node("level_button_template")

	-- Configuración de la grilla
	local columns = 3
	local rows = 5
	local button_size = gui.get_size(button_template)
	local spacing = vmath.vector3(20, 20, 0) -- Espacio entre botones

	-- Punto de inicio para la grilla (ajusta estos valores para centrar la grilla)
	local start_x = 200
	local start_y = 500

	-- Itera a través de los datos de los niveles para crear los botones
	for i, level_data in ipairs(self.levels_data) do
		-- Calcula la posición en la grilla
		local row = math.floor((i - 1) / columns)
		local col = (i - 1) % columns

		local pos_x = start_x + col * (button_size.x + spacing.x)
		local pos_y = start_y - row * (button_size.y + spacing.y)
		local position = vmath.vector3(pos_x, pos_y, 0)

		-- Clona el árbol de nodos de la plantilla (el botón y su texto hijo)
		local new_button_nodes = gui.clone_tree(button_template)

		-- El nodo principal del botón
		local button_node = new_button_nodes[gui.get_id(button_template)]
		gui.set_position(button_node, position)
		gui.set_enabled(button_node, true)

		-- El nodo de texto hijo
		local text_node_template = gui.get_node("level_number")
		local text_node = new_button_nodes[gui.get_id(text_node_template)]
		gui.set_text(text_node, tostring(level_data.level))

		-- Elige el sprite correcto basado en el estado del nivel
		local sprite_name
		if level_data.done then
			sprite_name = "level_done"
		elseif level_data.open then
			sprite_name = "level"
		else
			sprite_name = "level_blocked"
		end

		-- Establece la textura del nodo del botón
		-- NOTA: "level_done", "level", y "level_blocked" deben ser los nombres
		-- de las imágenes/animaciones en tu atlas.
		gui.play_flipbook(button_node, hash(sprite_name))

		-- Almacena el nodo del botón y sus datos para manejar el input más tarde
		table.insert(self.level_buttons, {
			node = button_node,
			level = level_data.level,
			open = level_data.open
		})
	end

	-- Deshabilita la plantilla original para que no sea visible
	gui.set_enabled(button_template, false)
end

function on_input(self, action_id, action)
	-- Comprueba si la acción es un toque o clic del ratón
	if action_id == hash("touch") and action.pressed then
		-- Itera a través de nuestros botones de nivel generados
		for i, button_data in ipairs(self.level_buttons) do
			-- Comprueba si el toque ocurrió dentro de los límites de este botón
			if gui.pick_node(button_data.node, action.x, action.y) then
				-- Si el nivel está abierto, imprime el número del nivel
				if button_data.open then
					print("level selected: " .. button_data.level)
					-- Aquí es donde añadirías la lógica para iniciar el nivel,
					MANAGER.current_level = button_data.level
					msg.post("main:/main", "change_scene", { scene = "level" })
				else
					print("Level " .. button_data.level .. " is blocked.")
				end
				-- Sal del bucle una vez que se encuentra el botón presionado
				return true
			end
		end
	end
	return false
end