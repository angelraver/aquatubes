local B = require "scripts.basics"
local C = require "scripts.config"
local Grid = require "scripts.grid"
local Levels = require "scripts.levels"

function init(self)
	msg.post(".", "acquire_input_focus")
	math.randomseed(os.time())
	self.grid_level = Levels.level_1
	self.pipe_handled = nil
	self.level_complete = false
	self.board_pipes = B.place_random_pipes(self.grid_level)
	self.hover_tile = factory.create("#hover_factory", vmath.vector3(0))
end

function on_input(self, action_id, action)
	-- screen_to_iso ahora devuelve nil, nil si no hay una celda válida
	local iso_x, iso_y = B.screen_to_iso(action.x, action.y)

	if iso_x ~= nil and iso_y ~= nil and not self.level_complete then -- estamos en el area de la grilla
		local key = iso_x .. "," .. iso_y
		if not C.BANNED_CELLS_SET[key] then --Estamos sobre una celda válida.
			local world_pos = B.iso_to_world(iso_x, iso_y)
			local z = B.get_z_for_cell(iso_x, iso_y)
			local world_pos_with_z = B.iso_to_world(iso_x, iso_y, z)
			if self.pipe_handled ~= nil then
				world_pos = world_pos_with_z -- seteo el z adecuado ahora que el hover es pipe
			end

			local updated_cell
			if action.released then
				local cell_with_pipe = B.get_cell_by_coords(self.board_pipes, iso_x, iso_y)	-- verificando si hay pipe en la celda clickeada

				-- [[ NUEVA VERIFICACIÓN ]]
				-- Comprobamos si existe una tubería en la celda y si su tipo es mayor a 20.
				if cell_with_pipe and cell_with_pipe.type > 20 then
					-- Si es así, la celda está bloqueada. No hacemos nada.
					print("celda bloqueada") -- Aquí puedes poner un sonido de "acción no permitida".
				else
					-- Si la celda no está bloqueada (o está vacía), procedemos con la lógica original.
					if self.pipe_handled then	-- hay un pipe seleccionado
						if cell_with_pipe then	-- click en celda con pipe -> intercambio los pipes:
							go.delete(self.hover_tile)	-- borro el hover_tile
							go.delete(cell_with_pipe.id)	-- borro del tablero el pipe presente
							B.delete_cell_by_coords(self.board_pipes, iso_x, iso_y)	-- borro la celda de la tabla tablero
							updated_cell = B.place_pipe(self.pipe_handled.type, iso_x, iso_y)	-- deposito en el tablero el pipe_handle
							table.insert(self.board_pipes, updated_cell)	-- guardo la celda alterada en la tabla tablero
							self.pipe_handled = cell_with_pipe	-- reemplazo el pipe_handled
							self.hover_tile = B.factory_pipe(cell_with_pipe.type)	-- creo un hover_tile con el pipe presente
						else	--click en celda sin pipe -> deposito el pipe_handled
							go.delete(self.hover_tile)	-- borro el hover_tile
							updated_cell = B.place_pipe(self.pipe_handled.type, iso_x, iso_y)	-- deposito en el tablero el pipe_handle
							table.insert(self.board_pipes, updated_cell)	-- guardo la celda alterada en la tabla tablero
							self.pipe_handled = nil	-- vacio el pipe_handled
							self.hover_tile = factory.create("#hover_factory", vmath.vector3(0)) -- reestablezco el hover tile
						end
					else	-- no hay pipe seleccionado
						if cell_with_pipe then	-- click en celda con pipe -> tomamos el pipe
							self.pipe_handled = cell_with_pipe -- guardo la celda en el pipe_handled
							go.delete(self.hover_tile) -- borro el hove actual
							go.delete(cell_with_pipe.id) -- borro del tablero el pipe presente
							B.delete_cell_by_coords(self.board_pipes, iso_x, iso_y)	-- borro la celda de la tabla tablero
							self.hover_tile = B.factory_pipe(cell_with_pipe.type)	-- creo un hover_tile con el pipe presente
						end
						--------------- click en celda sin pipe no hacemos nada
					end

					self.level_complete = B.check_level_complete(self.grid_level, self.board_pipes)
					if (self.level_complete) then
						local victory_id = factory.create("#done_factory", vmath.vector3(300, 300, 1))
						self.victory_go = victory_id
					end
				end
			end
			go.set_position(world_pos, self.hover_tile) -- reubico el hover al lugar actual
		else
			-- Fuera de la cuadrícula o de una celda válida. Ocultamos el hover.
			go.set_position(vmath.vector3(10000, 10000, 0), self.hover_tile)
		end
	end
end


function update(self, dt)
	Grid.draw_grid()
end
